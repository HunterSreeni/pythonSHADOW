#!/usr/bin/env python3
"""
SHADOW Phase 4 - Vulnerability Chain Builder.

Identifies exploitable vulnerability chains from a collection of findings.
Chains amplify individual findings into higher-impact attack paths.

Usage:
    python3 C_chain_builder.py --findings findings_dir/ --output chains.json
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
from core.result_manager import Finding, Severity


# ---------------------------------------------------------------------------
# Chain Pattern Definitions
# ---------------------------------------------------------------------------

CHAIN_PATTERNS: List[Dict[str, Any]] = [
    {
        "name": "SSRF to Internal Access",
        "requires": ["ssrf"],
        "amplifies": ["idor", "auth_bypass", "info_disclosure"],
        "description": (
            "SSRF provides access to internal services. Combined with IDOR or "
            "auth bypass on internal endpoints, this escalates to full internal "
            "network compromise."
        ),
        "max_severity": "critical",
    },
    {
        "name": "XSS to Account Takeover",
        "requires": ["xss"],
        "amplifies": ["csrf", "session_hijack", "cookie_theft"],
        "description": (
            "Stored or reflected XSS enables session token theft or CSRF bypass, "
            "leading to full account takeover of any user who triggers the payload."
        ),
        "max_severity": "critical",
    },
    {
        "name": "Open Redirect to OAuth Token Theft",
        "requires": ["open_redirect"],
        "amplifies": ["oauth_miscfg", "auth_bypass"],
        "description": (
            "Open redirect on a trusted OAuth callback domain allows interception "
            "of authorization codes or tokens via redirect_uri manipulation."
        ),
        "max_severity": "high",
    },
    {
        "name": "IDOR to Mass Data Exfiltration",
        "requires": ["idor"],
        "amplifies": ["info_disclosure", "enumeration"],
        "description": (
            "IDOR on a data endpoint combined with predictable identifiers or "
            "enumeration enables mass data exfiltration across all users."
        ),
        "max_severity": "critical",
    },
    {
        "name": "CSRF to Privilege Escalation",
        "requires": ["csrf"],
        "amplifies": ["privilege_escalation", "admin_action"],
        "description": (
            "CSRF on administrative endpoints enables an attacker to trick admins "
            "into performing privilege escalation actions."
        ),
        "max_severity": "high",
    },
    {
        "name": "SQL Injection to Full Compromise",
        "requires": ["sqli"],
        "amplifies": ["auth_bypass", "rce", "info_disclosure"],
        "description": (
            "SQL injection provides direct database access. Combined with file "
            "write or stacked queries, this escalates to RCE or full data breach."
        ),
        "max_severity": "critical",
    },
    {
        "name": "XXE to SSRF and File Read",
        "requires": ["xxe"],
        "amplifies": ["ssrf", "file_read", "info_disclosure"],
        "description": (
            "XXE enables local file reading and internal SSRF. When combined with "
            "sensitive file paths or internal service access, impact is severe."
        ),
        "max_severity": "critical",
    },
    {
        "name": "SSTI to Remote Code Execution",
        "requires": ["ssti"],
        "amplifies": ["rce", "file_read"],
        "description": (
            "Server-side template injection provides code execution within the "
            "template engine sandbox. Sandbox escape leads to full RCE."
        ),
        "max_severity": "critical",
    },
    {
        "name": "CORS Misconfiguration to Data Theft",
        "requires": ["cors_miscfg"],
        "amplifies": ["info_disclosure", "session_hijack"],
        "description": (
            "Permissive CORS policy allows attacker-controlled origins to read "
            "authenticated API responses, leading to data theft."
        ),
        "max_severity": "high",
    },
    {
        "name": "Race Condition to Financial Impact",
        "requires": ["race_condition"],
        "amplifies": ["payment_bypass", "business_logic"],
        "description": (
            "Race condition in transaction processing allows duplicate operations, "
            "leading to financial manipulation or resource duplication."
        ),
        "max_severity": "high",
    },
    {
        "name": "Info Disclosure to Targeted Attack",
        "requires": ["info_disclosure"],
        "amplifies": ["sqli", "ssrf", "auth_bypass", "idor"],
        "description": (
            "Information disclosure (stack traces, config files, API keys) provides "
            "the intelligence needed to craft targeted exploitation of other vulns."
        ),
        "max_severity": "high",
    },
]

# Mapping of keywords to vulnerability tags
_VULN_TAG_KEYWORDS: Dict[str, List[str]] = {
    "ssrf": ["ssrf", "server-side request forgery", "internal request"],
    "xss": ["xss", "cross-site scripting", "script injection", "reflected xss", "stored xss", "dom xss"],
    "csrf": ["csrf", "cross-site request forgery"],
    "idor": ["idor", "insecure direct object", "broken object level", "bola"],
    "sqli": ["sql injection", "sqli", "blind sql", "time-based sql"],
    "xxe": ["xxe", "xml external entity"],
    "ssti": ["ssti", "template injection", "server-side template"],
    "rce": ["rce", "remote code execution", "command injection", "os command"],
    "open_redirect": ["open redirect", "url redirect", "redirect"],
    "cors_miscfg": ["cors", "cross-origin"],
    "auth_bypass": ["auth bypass", "authentication bypass", "broken auth"],
    "privilege_escalation": ["privilege escalation", "priv esc", "vertical escalation"],
    "info_disclosure": ["information disclosure", "info leak", "data exposure", "sensitive data"],
    "session_hijack": ["session hijack", "session fixation", "token theft"],
    "cookie_theft": ["cookie", "httponly", "session cookie"],
    "oauth_miscfg": ["oauth", "openid", "authorization code"],
    "race_condition": ["race condition", "toctou", "concurrency"],
    "payment_bypass": ["payment", "price manipulation", "financial"],
    "business_logic": ["business logic", "workflow bypass"],
    "file_read": ["file read", "path traversal", "lfi", "local file inclusion"],
    "enumeration": ["enumeration", "brute force", "predictable"],
    "admin_action": ["admin", "administrative"],
    "clickjacking": ["clickjacking", "ui redress", "frame"],
}


class ChainBuilder:
    """Identifies vulnerability chains from a collection of findings."""

    def __init__(self, patterns: Optional[List[Dict]] = None):
        self.patterns = patterns or CHAIN_PATTERNS

    def find_chains(self, findings: List[Finding]) -> List[Dict[str, Any]]:
        """
        Identify possible vulnerability chains.

        Returns a list of chain dicts with:
          - pattern: the matched CHAIN_PATTERNS entry
          - trigger_findings: findings that satisfy "requires"
          - amplifier_findings: findings that satisfy "amplifies"
          - combined_severity: the chain's rated severity
        """
        # Tag each finding
        tagged = [(f, self._tag_finding(f)) for f in findings]

        chains = []
        for pattern in self.patterns:
            required_tags = set(pattern["requires"])
            amplifier_tags = set(pattern["amplifies"])

            trigger_findings = [
                f for f, tags in tagged if required_tags & tags
            ]
            amplifier_findings = [
                f for f, tags in tagged if amplifier_tags & tags
            ]

            if trigger_findings and amplifier_findings:
                chains.append({
                    "pattern": pattern,
                    "trigger_findings": trigger_findings,
                    "amplifier_findings": amplifier_findings,
                    "combined_severity": pattern["max_severity"],
                })

        # Sort by severity
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
        chains.sort(key=lambda c: severity_order.get(c["combined_severity"], 5))

        return chains

    def describe_chain(self, chain: Dict[str, Any]) -> str:
        """Generate a human-readable description of a vulnerability chain."""
        pattern = chain["pattern"]
        triggers = chain["trigger_findings"]
        amplifiers = chain["amplifier_findings"]

        lines = [
            f"## Chain: {pattern['name']}",
            f"**Combined Severity:** {chain['combined_severity'].upper()}",
            "",
            f"### Description",
            pattern["description"],
            "",
            f"### Trigger Vulnerabilities ({len(triggers)})",
        ]
        for f in triggers:
            sev = getattr(f.severity, "value", f.severity).upper() if f.severity else "UNKNOWN"
            lines.append(f"- [{sev}] {f.title} @ `{f.url}`")

        lines.append(f"\n### Amplifier Vulnerabilities ({len(amplifiers)})")
        for f in amplifiers:
            sev = getattr(f.severity, "value", f.severity).upper() if f.severity else "UNKNOWN"
            lines.append(f"- [{sev}] {f.title} @ `{f.url}`")

        lines.append(f"\n### Attack Path")
        lines.append(f"1. Exploit **{triggers[0].title}** ({pattern['requires'][0]})")
        lines.append(f"2. Chain into **{amplifiers[0].title}** ({pattern['amplifies'][0]})")
        lines.append(f"3. Achieve: {pattern['name']}")

        return "\n".join(lines)

    def rate_chain_impact(self, chain: Dict[str, Any]) -> str:
        """Rate the combined impact of a chain."""
        severity = chain["combined_severity"]
        pattern = chain["pattern"]
        n_triggers = len(chain["trigger_findings"])
        n_amplifiers = len(chain["amplifier_findings"])

        lines = [
            f"Chain: {pattern['name']}",
            f"Severity: {severity.upper()}",
            f"Components: {n_triggers} trigger(s) + {n_amplifiers} amplifier(s)",
            "",
        ]

        if severity == "critical":
            lines.append(
                "IMPACT: This chain represents a critical-severity attack path. "
                "The combination of these vulnerabilities could lead to full "
                "system compromise, mass data breach, or complete authentication bypass."
            )
        elif severity == "high":
            lines.append(
                "IMPACT: This chain represents a high-severity attack path. "
                "Successful exploitation could lead to significant data access, "
                "privilege escalation, or account takeover."
            )
        else:
            lines.append(
                f"IMPACT: This chain is rated {severity}. While individual "
                "components may be lower severity, the combination amplifies "
                "the overall risk."
            )

        return "\n".join(lines)

    def to_json(self, chains: List[Dict[str, Any]]) -> str:
        """Serialize chains to JSON (findings converted to titles for readability)."""
        serializable = []
        for chain in chains:
            serializable.append({
                "name": chain["pattern"]["name"],
                "combined_severity": chain["combined_severity"],
                "description": chain["pattern"]["description"],
                "triggers": [
                    {"title": f.title, "severity": getattr(f.severity, "value", f.severity), "url": f.url}
                    for f in chain["trigger_findings"]
                ],
                "amplifiers": [
                    {"title": f.title, "severity": getattr(f.severity, "value", f.severity), "url": f.url}
                    for f in chain["amplifier_findings"]
                ],
            })
        return json.dumps(serializable, indent=2)

    # ------------------------------------------------------------------
    # Internal
    # ------------------------------------------------------------------

    @staticmethod
    def _tag_finding(finding: Finding) -> set:
        """Assign vulnerability tags to a finding based on title + description."""
        text = f"{finding.title} {finding.description}".lower()
        tags = set()
        for tag, keywords in _VULN_TAG_KEYWORDS.items():
            if any(kw in text for kw in keywords):
                tags.add(tag)
        # Also check metadata for explicit tags
        explicit_tags = finding.metadata.get("tags", [])
        if isinstance(explicit_tags, list):
            tags.update(t.lower() for t in explicit_tags)
        return tags


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description="SHADOW Vulnerability Chain Builder")
    parser.add_argument(
        "--findings",
        required=True,
        help="Path to directory of finding JSON files, or a single JSON file.",
    )
    parser.add_argument("--output", "-o", help="Output file for chain analysis.")

    args = parser.parse_args()
    path = Path(args.findings)

    # Load findings
    findings = []
    if path.is_dir():
        for fp in sorted(path.glob("*.json")):
            with open(fp) as f:
                findings.append(Finding.from_dict(json.load(f)))
    elif path.is_file():
        with open(path) as f:
            data = json.load(f)
        if isinstance(data, list):
            findings = [Finding.from_dict(d) for d in data]
        else:
            findings = [Finding.from_dict(data)]

    if not findings:
        print("No findings loaded.")
        return

    print(f"Loaded {len(findings)} findings.")

    builder = ChainBuilder()
    chains = builder.find_chains(findings)

    if not chains:
        print("No vulnerability chains identified.")
        return

    print(f"\nIdentified {len(chains)} vulnerability chain(s):\n")
    for chain in chains:
        print(builder.describe_chain(chain))
        print()
        print(builder.rate_chain_impact(chain))
        print("\n" + "=" * 60 + "\n")

    if args.output:
        output = Path(args.output)
        output.write_text(builder.to_json(chains))
        print(f"Chain analysis saved to: {args.output}")


if __name__ == "__main__":
    main()
