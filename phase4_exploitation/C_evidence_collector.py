#!/usr/bin/env python3
"""
SHADOW Phase 4 - Evidence Collector.

Captures and organizes exploitation evidence (HTTP request/response pairs,
screenshots, notes) with timestamps for report inclusion.

Usage:
    python3 C_evidence_collector.py --dir ./evidence --export timeline
    python3 C_evidence_collector.py --dir ./evidence --export finding --title "SSRF on /api"
"""

import argparse
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional


class EvidenceCollector:
    """
    Collects and organizes exploitation evidence with timestamps.

    Evidence is stored as JSON entries in a log file and individual
    request/response files in the output directory.
    """

    def __init__(self, output_dir: str):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.evidence_log: List[Dict[str, Any]] = []
        self._log_file = self.output_dir / "C_evidence_log.json"

        # Load existing log if present
        if self._log_file.exists():
            with open(self._log_file, "r") as f:
                self.evidence_log = json.load(f)

    def capture_request(
        self,
        method: str,
        url: str,
        headers: Dict[str, str],
        body: str,
        response_status: int,
        response_headers: Dict[str, str],
        response_body: str,
        notes: str = "",
        finding_title: str = "",
    ) -> Dict[str, Any]:
        """
        Store a full HTTP request/response pair with metadata.

        Returns the evidence entry dict.
        """
        entry_id = len(self.evidence_log) + 1
        timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

        entry = {
            "id": entry_id,
            "timestamp": timestamp,
            "finding_title": finding_title,
            "request": {
                "method": method,
                "url": url,
                "headers": headers,
                "body": body,
            },
            "response": {
                "status": response_status,
                "headers": response_headers,
                "body": response_body[:10000],  # Cap at 10KB
            },
            "notes": notes,
        }

        self.evidence_log.append(entry)
        self._save_log()

        # Also save individual evidence file
        evidence_file = self.output_dir / f"C_evidence_{entry_id:04d}.json"
        with open(evidence_file, "w") as f:
            json.dump(entry, f, indent=2)

        return entry

    def save_screenshot(self, url: str, filename: str, notes: str = "") -> str:
        """
        Record a screenshot reference.

        Actual screenshot capture requires browser automation (Playwright, Selenium)
        which is out of scope here. This records the metadata and expected path.

        Returns the expected file path.
        """
        filepath = self.output_dir / filename
        timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

        entry = {
            "id": len(self.evidence_log) + 1,
            "timestamp": timestamp,
            "type": "screenshot",
            "url": url,
            "file": str(filepath),
            "notes": notes,
        }

        self.evidence_log.append(entry)
        self._save_log()

        return str(filepath)

    def add_note(self, note: str, finding_title: str = "") -> Dict[str, Any]:
        """Add a timestamped note to the evidence log."""
        entry = {
            "id": len(self.evidence_log) + 1,
            "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "type": "note",
            "finding_title": finding_title,
            "notes": note,
        }
        self.evidence_log.append(entry)
        self._save_log()
        return entry

    def export_timeline(self) -> str:
        """Generate a chronological evidence timeline in Markdown."""
        if not self.evidence_log:
            return "No evidence collected."

        lines = [
            "# Evidence Timeline",
            "",
            f"Total entries: {len(self.evidence_log)}",
            "",
        ]

        for entry in sorted(self.evidence_log, key=lambda e: e.get("timestamp", "")):
            ts = entry.get("timestamp", "unknown")
            eid = entry.get("id", "?")
            entry_type = entry.get("type", "request")

            if entry_type == "screenshot":
                lines.append(f"### [{ts}] Evidence #{eid} — Screenshot")
                lines.append(f"- **URL:** {entry.get('url', 'N/A')}")
                lines.append(f"- **File:** {entry.get('file', 'N/A')}")
            elif entry_type == "note":
                lines.append(f"### [{ts}] Evidence #{eid} — Note")
                finding = entry.get("finding_title", "")
                if finding:
                    lines.append(f"- **Finding:** {finding}")
            else:
                req = entry.get("request", {})
                resp = entry.get("response", {})
                lines.append(f"### [{ts}] Evidence #{eid} — HTTP Request")
                lines.append(f"- **Method:** {req.get('method', 'GET')}")
                lines.append(f"- **URL:** {req.get('url', 'N/A')}")
                lines.append(f"- **Status:** {resp.get('status', 'N/A')}")

                finding = entry.get("finding_title", "")
                if finding:
                    lines.append(f"- **Finding:** {finding}")

            notes = entry.get("notes", "")
            if notes:
                lines.append(f"- **Notes:** {notes}")
            lines.append("")

        return "\n".join(lines)

    def export_for_report(self, finding_title: str) -> List[Dict[str, Any]]:
        """Filter and return evidence entries relevant to a specific finding."""
        return [
            entry for entry in self.evidence_log
            if entry.get("finding_title", "").lower() == finding_title.lower()
        ]

    def export_raw_request(self, entry_id: int) -> str:
        """Export an evidence entry as a raw HTTP request string."""
        entry = self._get_entry(entry_id)
        if not entry or "request" not in entry:
            return f"Evidence #{entry_id} not found or has no request data."

        req = entry["request"]
        resp = entry["response"]

        lines = [
            f"{req['method']} {req['url']} HTTP/1.1",
        ]
        for k, v in req.get("headers", {}).items():
            lines.append(f"{k}: {v}")
        lines.append("")
        if req.get("body"):
            lines.append(req["body"])

        lines.append("")
        lines.append(f"HTTP/1.1 {resp.get('status', '???')}")
        for k, v in resp.get("headers", {}).items():
            lines.append(f"{k}: {v}")
        lines.append("")
        body = resp.get("body", "")
        if body:
            lines.append(body[:2000])

        return "\n".join(lines)

    def summary(self) -> Dict[str, Any]:
        """Return a summary of collected evidence."""
        types = {}
        findings = set()
        for entry in self.evidence_log:
            t = entry.get("type", "request")
            types[t] = types.get(t, 0) + 1
            ft = entry.get("finding_title", "")
            if ft:
                findings.add(ft)

        return {
            "total_entries": len(self.evidence_log),
            "entry_types": types,
            "unique_findings": sorted(findings),
            "output_dir": str(self.output_dir),
        }

    # ------------------------------------------------------------------
    # Internal
    # ------------------------------------------------------------------

    def _save_log(self):
        """Persist the evidence log to disk."""
        with open(self._log_file, "w") as f:
            json.dump(self.evidence_log, f, indent=2)

    def _get_entry(self, entry_id: int) -> Optional[Dict[str, Any]]:
        """Find an entry by ID."""
        for entry in self.evidence_log:
            if entry.get("id") == entry_id:
                return entry
        return None


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description="SHADOW Evidence Collector")
    parser.add_argument(
        "--dir", required=True, help="Evidence output directory."
    )
    parser.add_argument(
        "--export",
        choices=["timeline", "finding", "summary", "raw"],
        default="summary",
        help="Export mode.",
    )
    parser.add_argument("--title", help="Finding title (for --export finding).")
    parser.add_argument("--entry-id", type=int, help="Entry ID (for --export raw).")

    args = parser.parse_args()
    collector = EvidenceCollector(args.dir)

    if args.export == "timeline":
        print(collector.export_timeline())
    elif args.export == "finding":
        if not args.title:
            parser.error("--title is required for --export finding")
        entries = collector.export_for_report(args.title)
        print(json.dumps(entries, indent=2))
    elif args.export == "raw":
        if not args.entry_id:
            parser.error("--entry-id is required for --export raw")
        print(collector.export_raw_request(args.entry_id))
    else:
        print(json.dumps(collector.summary(), indent=2))


if __name__ == "__main__":
    main()
