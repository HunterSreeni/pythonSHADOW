#!/usr/bin/env python3
"""
SHADOW Phase 4 - Proof-of-Concept Generator.

Generates reproducible PoC code in multiple formats (curl, Python, HTML)
from Finding objects.

Usage:
    python3 C_poc_generator.py --finding finding.json --format all
    python3 C_poc_generator.py --finding finding.json --format curl
    python3 C_poc_generator.py --finding finding.json --format python --output poc_script.py
"""

import argparse
import html
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional
from urllib.parse import parse_qs, urlencode, urlparse

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
from core.result_manager import Finding, Severity


class PoCGenerator:
    """
    Generates proof-of-concept exploit code from vulnerability findings.

    Supports:
      - curl commands
      - Python requests scripts
      - HTML pages (for client-side vulns: CSRF, XSS, clickjacking)
    """

    def generate_curl(self, finding: Finding) -> str:
        """Generate a curl command reproducing the vulnerability."""
        parts = ["curl -v"]

        method, url, headers, body = self._parse_request(finding)

        # Method
        if method and method.upper() != "GET":
            parts.append(f"-X {method.upper()}")

        # Headers
        for name, value in headers.items():
            parts.append(f"-H '{name}: {value}'")

        # Body
        if body:
            # Determine content type for proper flag
            ct = headers.get("Content-Type", headers.get("content-type", ""))
            if "application/json" in ct:
                parts.append(f"--json '{body}'")
            else:
                parts.append(f"-d '{body}'")

        # Cookies from metadata
        cookies = finding.metadata.get("cookies")
        if cookies:
            parts.append(f"-b '{cookies}'")

        # If payload goes in URL parameter
        if finding.parameter and finding.payload and not body:
            parsed = urlparse(url)
            params = parse_qs(parsed.query, keep_blank_values=True)
            params[finding.parameter] = [finding.payload]
            new_query = urlencode(params, doseq=True)
            url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"

        parts.append(f"'{url}'")

        return " \\\n  ".join(parts)

    def generate_python(self, finding: Finding) -> str:
        """Generate a Python requests script reproducing the vulnerability."""
        method, url, headers, body = self._parse_request(finding)

        lines = [
            '#!/usr/bin/env python3',
            f'"""',
            f'PoC: {finding.title}',
            f'Severity: {getattr(finding.severity, "value", finding.severity).upper() if finding.severity else "UNKNOWN"}',
            f'Generated by SHADOW Framework',
            f'"""',
            '',
            'import requests',
            'import sys',
            '',
            '# Configuration',
            f'TARGET_URL = "{url}"',
        ]

        if finding.parameter and finding.payload:
            lines.append(f'PARAMETER = "{finding.parameter}"')
            lines.append(f'PAYLOAD = "{self._escape_python_str(finding.payload)}"')

        lines.append('')

        # Build request kwargs
        kwargs = {}
        if headers:
            lines.append('HEADERS = {')
            for k, v in headers.items():
                lines.append(f'    "{k}": "{self._escape_python_str(v)}",')
            lines.append('}')
            lines.append('')

        cookies = finding.metadata.get("cookies")
        if cookies:
            lines.append(f'COOKIES = "{self._escape_python_str(cookies)}"')
            lines.append('')

        lines.append('')
        lines.append('def exploit():')
        lines.append('    """Execute the proof of concept."""')
        lines.append('    session = requests.Session()')
        lines.append('    session.verify = True  # Enable TLS verification')
        lines.append('')

        if cookies:
            lines.append('    # Parse cookies')
            lines.append('    for pair in COOKIES.split("; "):')
            lines.append('        if "=" in pair:')
            lines.append('            k, v = pair.split("=", 1)')
            lines.append('            session.cookies.set(k.strip(), v.strip())')
            lines.append('')

        if headers:
            lines.append('    session.headers.update(HEADERS)')
            lines.append('')

        # Build the request call
        method_lower = (method or "GET").lower()
        if body:
            ct = headers.get("Content-Type", headers.get("content-type", ""))
            if "application/json" in ct:
                lines.append(f'    data = {body}')
                lines.append('')
                lines.append(f'    response = session.{method_lower}(TARGET_URL, json=data)')
            else:
                lines.append(f'    data = """{self._escape_python_str(body)}"""')
                lines.append('')
                lines.append(f'    response = session.{method_lower}(TARGET_URL, data=data)')
        elif finding.parameter and finding.payload:
            lines.append(f'    params = {{PARAMETER: PAYLOAD}}')
            lines.append('')
            lines.append(f'    response = session.{method_lower}(TARGET_URL, params=params)')
        else:
            lines.append(f'    response = session.{method_lower}(TARGET_URL)')

        lines.extend([
            '',
            '    # Report results',
            '    print(f"Status: {response.status_code}")',
            '    print(f"Headers: {dict(response.headers)}")',
            '    print(f"Body ({len(response.text)} chars):")',
            '    print(response.text[:2000])',
            '',
            '    return response',
            '',
            '',
            'if __name__ == "__main__":',
            '    print(f"[*] PoC: {finding.title}")',
            '    print(f"[*] Target: {TARGET_URL}")',
            '    print()',
            '    try:',
            '        resp = exploit()',
            '        if resp.status_code < 400:',
            '            print(f"\\n[+] Potential success (HTTP {resp.status_code})")',
            '        else:',
            '            print(f"\\n[-] Got HTTP {resp.status_code}")',
            '    except requests.RequestException as e:',
            '        print(f"\\n[!] Request failed: {e}", file=sys.stderr)',
            '        sys.exit(1)',
        ])

        # Fix the f-string that references finding (not available at runtime)
        # Replace with literal strings
        result = "\n".join(lines)
        result = result.replace(
            'f"[*] PoC: {finding.title}"',
            f'"[*] PoC: {self._escape_python_str(finding.title)}"'
        )
        result = result.replace(
            'f"[*] Target: {TARGET_URL}"',
            'f"[*] Target: {TARGET_URL}"'
        )

        return result

    def generate_html(self, finding: Finding) -> str:
        """
        Generate an HTML page for client-side vulnerabilities.

        Useful for:
          - CSRF proof-of-concept (auto-submitting form)
          - XSS demonstration
          - Clickjacking PoC (iframe overlay)
          - Open redirect demonstration
        """
        vuln_type = self._detect_vuln_type(finding)

        if vuln_type == "csrf":
            return self._generate_csrf_html(finding)
        elif vuln_type == "xss":
            return self._generate_xss_html(finding)
        elif vuln_type == "clickjacking":
            return self._generate_clickjacking_html(finding)
        elif vuln_type == "open_redirect":
            return self._generate_redirect_html(finding)
        else:
            return self._generate_generic_html(finding)

    def generate(self, finding: Finding, fmt: str = "all") -> Dict[str, str]:
        """
        Generate PoCs in one or all formats.

        Args:
            finding: The vulnerability finding.
            fmt: "curl", "python", "html", or "all".

        Returns:
            Dict mapping format name to generated content.
        """
        generators = {
            "curl": self.generate_curl,
            "python": self.generate_python,
            "html": self.generate_html,
        }

        if fmt == "all":
            return {name: gen(finding) for name, gen in generators.items()}

        if fmt not in generators:
            raise ValueError(f"Unknown format: {fmt}. Choose from: {list(generators.keys())}")

        return {fmt: generators[fmt](finding)}

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _parse_request(self, finding: Finding):
        """Parse the raw request string from a finding into components."""
        method = "GET"
        url = finding.url
        headers = {}
        body = ""

        if finding.request:
            lines = finding.request.strip().split("\n")
            if lines:
                # First line: METHOD /path HTTP/1.1
                first = lines[0].strip()
                parts = first.split(" ", 2)
                if len(parts) >= 2:
                    method = parts[0]
                    # If the path is relative, combine with URL
                    if parts[1].startswith("/"):
                        parsed = urlparse(finding.url)
                        url = f"{parsed.scheme}://{parsed.netloc}{parts[1]}"
                    elif parts[1].startswith("http"):
                        url = parts[1]

                # Parse headers and body
                body_start = False
                body_lines = []
                for line in lines[1:]:
                    if body_start:
                        body_lines.append(line)
                    elif line.strip() == "":
                        body_start = True
                    elif ":" in line:
                        key, val = line.split(":", 1)
                        headers[key.strip()] = val.strip()

                body = "\n".join(body_lines).strip()

        return method, url, headers, body

    def _detect_vuln_type(self, finding: Finding) -> str:
        """Detect vulnerability type from finding title/description."""
        text = f"{finding.title} {finding.description}".lower()

        if any(w in text for w in ("csrf", "cross-site request forgery", "forged request")):
            return "csrf"
        if any(w in text for w in ("xss", "cross-site scripting", "script injection")):
            return "xss"
        if any(w in text for w in ("clickjack", "ui redress", "iframe")):
            return "clickjacking"
        if any(w in text for w in ("open redirect", "url redirect", "redirect")):
            return "open_redirect"
        return "generic"

    def _generate_csrf_html(self, finding: Finding) -> str:
        method, url, headers, body = self._parse_request(finding)

        form_fields = ""
        if body:
            # Try JSON
            try:
                data = json.loads(body)
                for k, v in data.items():
                    escaped_v = html.escape(str(v))
                    form_fields += (
                        f'      <input type="hidden" name="{html.escape(k)}" '
                        f'value="{escaped_v}" />\n'
                    )
            except (json.JSONDecodeError, AttributeError):
                # Try URL-encoded
                pairs = parse_qs(body, keep_blank_values=True)
                for k, vals in pairs.items():
                    for v in vals:
                        form_fields += (
                            f'      <input type="hidden" name="{html.escape(k)}" '
                            f'value="{html.escape(v)}" />\n'
                        )

        return f"""<!DOCTYPE html>
<html>
<head>
  <title>CSRF PoC - {html.escape(finding.title)}</title>
</head>
<body>
  <h1>CSRF Proof of Concept</h1>
  <p>This page demonstrates a Cross-Site Request Forgery vulnerability.</p>
  <form id="csrf-form" method="{method}" action="{html.escape(url)}">
{form_fields}    <input type="submit" value="Submit" />
  </form>
  <script>
    // Auto-submit after 1 second
    setTimeout(function() {{
      document.getElementById('csrf-form').submit();
    }}, 1000);
  </script>
</body>
</html>"""

    def _generate_xss_html(self, finding: Finding) -> str:
        payload = finding.payload or "<script>alert(document.domain)</script>"
        return f"""<!DOCTYPE html>
<html>
<head>
  <title>XSS PoC - {html.escape(finding.title)}</title>
</head>
<body>
  <h1>XSS Proof of Concept</h1>
  <p><strong>Target:</strong> <a href="{html.escape(finding.url)}">{html.escape(finding.url)}</a></p>
  <p><strong>Parameter:</strong> {html.escape(finding.parameter or 'N/A')}</p>
  <p><strong>Payload:</strong></p>
  <pre>{html.escape(payload)}</pre>
  <hr>
  <p>To reproduce: inject the payload into the parameter above.</p>
  <p>If the target is reflected XSS, use this URL:</p>
  <pre>{html.escape(finding.url)}?{html.escape(finding.parameter or 'q')}={html.escape(payload)}</pre>
</body>
</html>"""

    def _generate_clickjacking_html(self, finding: Finding) -> str:
        return f"""<!DOCTYPE html>
<html>
<head>
  <title>Clickjacking PoC - {html.escape(finding.title)}</title>
  <style>
    body {{ margin: 0; padding: 20px; font-family: sans-serif; }}
    .overlay {{
      position: absolute; top: 100px; left: 100px;
      z-index: 2; opacity: 0.3;
    }}
    iframe {{
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1; opacity: 0.1;
      border: none;
    }}
  </style>
</head>
<body>
  <h1>Clickjacking Proof of Concept</h1>
  <p>The target page is loaded in a transparent iframe below.</p>
  <p>If this renders, the target lacks X-Frame-Options / CSP frame-ancestors.</p>
  <div class="overlay">
    <button style="font-size: 24px; padding: 20px;">Click here to win a prize!</button>
  </div>
  <iframe src="{html.escape(finding.url)}"></iframe>
</body>
</html>"""

    def _generate_redirect_html(self, finding: Finding) -> str:
        payload = finding.payload or "https://attacker.example.com"
        return f"""<!DOCTYPE html>
<html>
<head>
  <title>Open Redirect PoC - {html.escape(finding.title)}</title>
</head>
<body>
  <h1>Open Redirect Proof of Concept</h1>
  <p><strong>Target:</strong> {html.escape(finding.url)}</p>
  <p><strong>Parameter:</strong> {html.escape(finding.parameter or 'redirect_url')}</p>
  <p><strong>Redirect destination:</strong> {html.escape(payload)}</p>
  <hr>
  <p><a href="{html.escape(finding.url)}?{html.escape(finding.parameter or 'redirect_url')}={html.escape(payload)}">
    Click to trigger redirect
  </a></p>
</body>
</html>"""

    def _generate_generic_html(self, finding: Finding) -> str:
        return f"""<!DOCTYPE html>
<html>
<head>
  <title>PoC - {html.escape(finding.title)}</title>
</head>
<body>
  <h1>{html.escape(finding.title)}</h1>
  <p><strong>Severity:</strong> {html.escape(getattr(finding.severity, "value", finding.severity).upper() if finding.severity else "UNKNOWN")}</p>
  <p><strong>URL:</strong> <a href="{html.escape(finding.url)}">{html.escape(finding.url)}</a></p>
  <h2>Description</h2>
  <p>{html.escape(finding.description)}</p>
  <h2>Evidence</h2>
  <pre>{html.escape(finding.evidence or 'No evidence captured.')}</pre>
</body>
</html>"""

    @staticmethod
    def _escape_python_str(s: str) -> str:
        """Escape a string for use inside Python double quotes."""
        return s.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="SHADOW PoC Generator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("--finding", required=True, help="Path to finding JSON file.")
    parser.add_argument(
        "--format",
        choices=["curl", "python", "html", "all"],
        default="all",
        help="PoC format to generate (default: all).",
    )
    parser.add_argument("--output", "-o", help="Output file path (single format only).")

    args = parser.parse_args()

    with open(args.finding, "r") as f:
        data = json.load(f)
    finding = Finding.from_dict(data)

    gen = PoCGenerator()
    results = gen.generate(finding, args.format)

    if args.output and len(results) == 1:
        fmt_name, content = next(iter(results.items()))
        Path(args.output).write_text(content)
        print(f"PoC ({fmt_name}) saved to: {args.output}")
    else:
        for fmt_name, content in results.items():
            print(f"\n{'=' * 60}")
            print(f"  PoC Format: {fmt_name.upper()}")
            print(f"{'=' * 60}\n")
            print(content)


if __name__ == "__main__":
    main()
