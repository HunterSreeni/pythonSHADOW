#!/usr/bin/env python3
"""
SHADOW Authentication Suite - Coordinated auth testing.

Coordinates (all Python-primary):
- jwt_tester.py (algorithm confusion, none algorithm, weak secrets)
- login_bypass.py (default creds, SQLi bypass)
- session_tester.py (fixation, hijacking, cookie analysis)
- password_reset.py (token analysis, host header injection)
- hydra integration for credential brute force

Usage (CLI):
    python C_auth_suite.py -t https://example.com -o results/
    python C_auth_suite.py -t https://example.com --token "eyJ..." --login-url /login

Usage (importable):
    from C_unified_exploits.C_auth_suite import AuthSuite
    suite = AuthSuite(target="https://example.com")
    result = await suite.run()
"""

import argparse
import asyncio
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional

sys.path.insert(0, str(Path(__file__).parent.parent))

from core.utils import setup_logging, normalize_url, timestamp_now, ensure_dir
from C_wrappers.C_tool_router import ToolRouter, UnifiedResult

logger = setup_logging("auth_suite")


class AuthSuite:
    """
    Coordinated authentication testing suite.

    All Python-primary modules (no Kali equivalents for these tests).
    Optional hydra integration for credential brute force.
    """

    AUTH_MODULES = ["jwt", "login_bypass", "session", "password_reset"]

    def __init__(
        self,
        target: str,
        output_dir: str = "results",
        modules: Optional[List[str]] = None,
        token: Optional[str] = None,
        cookie: Optional[str] = None,
        login_url: Optional[str] = None,
        username_field: str = "username",
        password_field: str = "password",
        brute_force: bool = False,
        timeout: int = 300,
        proxy: Optional[str] = None,
    ):
        self.target = normalize_url(target)
        self.output_dir = Path(output_dir)
        self.modules = [m.lower() for m in (modules or self.AUTH_MODULES)]
        self.token = token
        self.cookie = cookie
        self.login_url = login_url
        self.username_field = username_field
        self.password_field = password_field
        self.brute_force = brute_force
        self.timeout = timeout
        self.proxy = proxy
        self.router = ToolRouter()

    async def run(self) -> UnifiedResult:
        """Run all requested authentication tests."""
        logger.info(f"Starting Auth Suite for: {self.target}")
        result = UnifiedResult(tool_used="auth_suite", target=self.target)
        all_findings: List[Dict[str, Any]] = []
        module_results: Dict[str, Any] = {}

        for mod in self.modules:
            logger.info(f"Testing: {mod}")
            try:
                if mod == "jwt" and self.token:
                    findings = await self._test_jwt()
                elif mod == "jwt" and not self.token:
                    logger.info("  Skipping JWT testing (no token provided)")
                    module_results[mod] = {"skipped": True, "reason": "no token"}
                    continue
                elif mod == "login_bypass":
                    findings = await self._test_login_bypass()
                elif mod == "session":
                    findings = await self._test_session()
                elif mod == "password_reset":
                    findings = await self._test_password_reset()
                else:
                    logger.warning(f"  Unknown module: {mod}")
                    continue

                all_findings.extend(findings)
                module_results[mod] = {"findings_count": len(findings)}
                logger.info(f"  {mod}: {len(findings)} findings")

            except Exception as e:
                logger.error(f"  {mod} failed: {e}")
                module_results[mod] = {"error": str(e)}

        # Optional: hydra brute force
        if self.brute_force and self.login_url:
            logger.info("Testing: credential brute force (hydra)")
            try:
                hydra_findings = await self._run_hydra()
                all_findings.extend(hydra_findings)
                module_results["hydra"] = {"findings_count": len(hydra_findings)}
            except Exception as e:
                logger.error(f"  hydra failed: {e}")
                module_results["hydra"] = {"error": str(e)}

        result.findings = all_findings
        result.parsed_data = {
            "modules_tested": self.modules,
            "total_findings": len(all_findings),
            "module_results": module_results,
        }

        return result

    async def _test_jwt(self) -> List[Dict[str, Any]]:
        """Test JWT vulnerabilities."""
        return await self._run_python_module(
            "phase3_testing.auth.jwt_tester", "JWTTester",
            extra_kwargs={"token": self.token} if self.token else {},
        )

    async def _test_login_bypass(self) -> List[Dict[str, Any]]:
        """Test login bypass techniques."""
        return await self._run_python_module(
            "phase3_testing.auth.login_bypass", "LoginBypassTester",
        )

    async def _test_session(self) -> List[Dict[str, Any]]:
        """Test session management vulnerabilities."""
        return await self._run_python_module(
            "phase3_testing.auth.session_tester", "SessionTester",
        )

    async def _test_password_reset(self) -> List[Dict[str, Any]]:
        """Test password reset vulnerabilities."""
        return await self._run_python_module(
            "phase3_testing.auth.password_reset", "PasswordResetTester",
        )

    async def _run_python_module(
        self,
        module_path: str,
        class_name: str,
        extra_kwargs: Optional[Dict] = None,
    ) -> List[Dict[str, Any]]:
        """Run a Python auth testing module."""
        findings = []
        try:
            module = __import__(module_path, fromlist=[class_name])
            tester_class = getattr(module, class_name)

            import inspect
            sig = inspect.signature(tester_class.__init__)
            valid_params = set(sig.parameters.keys()) - {"self"}
            kwargs: Dict[str, Any] = {}
            if "target" in valid_params:
                kwargs["target"] = self.target
            if "output_dir" in valid_params:
                kwargs["output_dir"] = str(self.output_dir)
            if "proxy" in valid_params and self.proxy:
                kwargs["proxy"] = self.proxy
            if "auth_cookie" in valid_params and self.cookie:
                kwargs["auth_cookie"] = self.cookie

            if extra_kwargs:
                for k, v in extra_kwargs.items():
                    if k in valid_params:
                        kwargs[k] = v

            tester = tester_class(**kwargs)

            scan_result = None
            for method_name in ["test", "scan", "run"]:
                if hasattr(tester, method_name):
                    scan_result = await getattr(tester, method_name)()
                    break

            if scan_result and hasattr(scan_result, "findings"):
                for finding in scan_result.findings:
                    fd = finding.to_dict() if hasattr(finding, "to_dict") else {}
                    fd["tool"] = f"python_{class_name}"
                    fd["category"] = "authentication"
                    findings.append(fd)

        except Exception as e:
            logger.error(f"Python module {class_name} failed: {e}")

        return findings

    async def _run_hydra(self) -> List[Dict[str, Any]]:
        """Run hydra for credential brute force (if login URL provided)."""
        if not self.router.is_available("hydra"):
            logger.warning("hydra not available for brute force")
            return []

        if not self.login_url:
            return []

        # Build hydra args for HTTP form
        login_url = self.login_url if self.login_url.startswith("http") else f"{self.target.rstrip('/')}{self.login_url}"

        args = [
            "-L", "/usr/share/wordlists/fasttrack.txt",  # Small username list
            "-P", "/usr/share/wordlists/fasttrack.txt",  # Small password list
            "-f",  # Stop on first valid pair
            "-t", "4",  # 4 threads (be gentle)
            "-V",
        ]

        # Parse target for hydra
        from urllib.parse import urlparse
        parsed = urlparse(login_url)
        host = parsed.hostname
        port = parsed.port or (443 if parsed.scheme == "https" else 80)
        path = parsed.path or "/login"

        if parsed.scheme == "https":
            args += [f"{host}", "https-post-form",
                     f"{path}:{self.username_field}=^USER^&{self.password_field}=^PASS^:Invalid"]
        else:
            args += [f"{host}", "http-post-form",
                     f"{path}:{self.username_field}=^USER^&{self.password_field}=^PASS^:Invalid"]

        if port not in (80, 443):
            args += ["-s", str(port)]

        tool_result = await self.router.run_tool(
            "hydra", args, target=login_url, timeout=self.timeout
        )

        findings = []
        if tool_result.raw_output and ("login:" in tool_result.raw_output.lower() or
                                        "password:" in tool_result.raw_output.lower()):
            findings.append({
                "title": "Valid Credentials Found (hydra brute force)",
                "severity": "critical",
                "url": login_url,
                "tool": "hydra",
                "evidence": tool_result.raw_output[:500],
                "category": "authentication",
            })

        return findings


async def main():
    parser = argparse.ArgumentParser(
        description="SHADOW Auth Suite - Coordinated authentication testing",
    )
    parser.add_argument("-t", "--target", required=True, help="Target URL")
    parser.add_argument("-o", "--output", default="results", help="Output directory")
    parser.add_argument("--modules", help="Auth modules (comma-separated: jwt,login_bypass,session,password_reset)")
    parser.add_argument("--token", help="JWT token for testing")
    parser.add_argument("--cookie", help="Auth cookie string")
    parser.add_argument("--login-url", help="Login form URL path (for brute force)")
    parser.add_argument("--brute-force", action="store_true", help="Enable hydra brute force")
    parser.add_argument("--timeout", type=int, default=300, help="Timeout in seconds")
    parser.add_argument("--proxy", help="Proxy URL")
    parser.add_argument("--json", action="store_true", help="Output as JSON")

    args = parser.parse_args()
    ensure_dir(args.output)

    modules = args.modules.split(",") if args.modules else None

    suite = AuthSuite(
        target=args.target,
        output_dir=args.output,
        modules=modules,
        token=args.token,
        cookie=args.cookie,
        login_url=args.login_url,
        brute_force=args.brute_force,
        timeout=args.timeout,
        proxy=args.proxy,
    )

    result = await suite.run()

    if args.json:
        print(result.to_json())
    else:
        print(f"\nAuth Suite Results: {len(result.findings)} findings")
        print(f"Modules tested: {', '.join(result.parsed_data.get('modules_tested', []))}\n")
        for finding in result.findings:
            sev = finding.get("severity", "?").upper()
            title = finding.get("title", "Unknown")
            tool = finding.get("tool", "?")
            print(f"  [{sev}] {title} ({tool})")


if __name__ == "__main__":
    asyncio.run(main())
