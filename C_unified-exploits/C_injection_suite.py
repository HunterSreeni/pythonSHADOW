#!/usr/bin/env python3
"""
SHADOW Injection Suite - Coordinated injection testing across all types.

Coordinates:
- sqli_tester.py -> sqlmap (screen + exploit)
- xss_tester.py (context-aware)
- ssti_tester.py (multi-engine detection)
- command_injection.py -> commix (screen + exploit)
- xxe_tester.py (file disclosure, SSRF, blind)

Tests all injection types against discovered parameters.
Routes to best tool per injection type.

Usage (CLI):
    python C_injection_suite.py -t "https://example.com/search?q=test" -o results/
    python C_injection_suite.py -t "https://example.com/search?q=test" --types sqli,xss

Usage (importable):
    from C_unified_exploits.C_injection_suite import InjectionSuite
    suite = InjectionSuite(target="https://example.com/search?q=test")
    result = await suite.run()
"""

import argparse
import asyncio
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

sys.path.insert(0, str(Path(__file__).parent.parent))

from core.utils import setup_logging, normalize_url, timestamp_now, ensure_dir
from core.result_manager import ScanResult, Finding, Severity
from C_wrappers.C_tool_router import ToolRouter, UnifiedResult

logger = setup_logging("injection_suite")


class InjectionSuite:
    """
    Coordinated injection testing suite.

    Routes each injection type to the best available tool:
    - SQLi: Python screen -> sqlmap exploit
    - XSS: Python xss_tester (primary, context-aware)
    - SSTI: Python ssti_tester (primary, no Kali equivalent)
    - CMDi: Python screen -> commix exploit
    - XXE: Python xxe_tester (primary, no Kali equivalent)
    """

    INJECTION_TYPES = ["sqli", "xss", "ssti", "cmdi", "xxe"]

    def __init__(
        self,
        target: str,
        output_dir: str = "results",
        types: Optional[List[str]] = None,
        exploit: bool = True,
        timeout: int = 600,
        proxy: Optional[str] = None,
        cookie: Optional[str] = None,
        data: Optional[str] = None,
        method: str = "GET",
    ):
        self.target = normalize_url(target)
        self.output_dir = Path(output_dir)
        self.types = [t.lower() for t in (types or self.INJECTION_TYPES)]
        self.exploit = exploit
        self.timeout = timeout
        self.proxy = proxy
        self.cookie = cookie
        self.data = data
        self.method = method.upper()
        self.router = ToolRouter()

    async def run(self) -> UnifiedResult:
        """Run all requested injection tests."""
        logger.info(f"Starting Injection Suite for: {self.target}")
        logger.info(f"Testing types: {', '.join(self.types)}")

        result = UnifiedResult(tool_used="injection_suite", target=self.target)
        all_findings: List[Dict[str, Any]] = []
        type_results: Dict[str, Any] = {}

        # Run each injection type
        tasks = {}
        for inj_type in self.types:
            if inj_type == "sqli":
                tasks["sqli"] = self._test_sqli()
            elif inj_type == "xss":
                tasks["xss"] = self._test_xss()
            elif inj_type == "ssti":
                tasks["ssti"] = self._test_ssti()
            elif inj_type == "cmdi":
                tasks["cmdi"] = self._test_cmdi()
            elif inj_type == "xxe":
                tasks["xxe"] = self._test_xxe()

        # Run all tests (sequentially to avoid overwhelming target)
        for inj_type, coro in tasks.items():
            logger.info(f"Testing: {inj_type.upper()}")
            try:
                findings = await coro
                all_findings.extend(findings)
                type_results[inj_type] = {
                    "findings_count": len(findings),
                    "findings": findings,
                }
                logger.info(f"  {inj_type.upper()}: {len(findings)} findings")
            except Exception as e:
                logger.error(f"  {inj_type.upper()} failed: {e}")
                type_results[inj_type] = {"error": str(e), "findings_count": 0}

        # Sort by severity
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
        all_findings.sort(key=lambda f: severity_order.get(f.get("severity", "info").lower(), 5))

        result.findings = all_findings
        result.parsed_data = {
            "types_tested": self.types,
            "total_findings": len(all_findings),
            "results_by_type": type_results,
            "severity_breakdown": self._severity_breakdown(all_findings),
        }

        return result

    async def _test_sqli(self) -> List[Dict[str, Any]]:
        """Test SQL injection: Python screen -> sqlmap exploit."""
        findings = []

        # Screen with Python
        screen_findings = await self._run_python_module(
            "phase3_testing.injection.sqli_tester", "SQLiTester"
        )
        findings.extend(screen_findings)

        # Exploit with sqlmap if screening found something
        if screen_findings and self.exploit and self.router.is_available("sqlmap"):
            sqlmap_findings = await self._run_sqlmap()
            findings.extend(sqlmap_findings)

        for f in findings:
            f["injection_type"] = "sqli"
        return findings

    async def _test_xss(self) -> List[Dict[str, Any]]:
        """Test XSS: Python xss_tester (primary, context-aware)."""
        findings = await self._run_python_module(
            "phase3_testing.injection.xss_tester", "XSSTester"
        )
        for f in findings:
            f["injection_type"] = "xss"
        return findings

    async def _test_ssti(self) -> List[Dict[str, Any]]:
        """Test SSTI: Python ssti_tester (primary, no Kali equivalent)."""
        findings = await self._run_python_module(
            "phase3_testing.injection.ssti_tester", "SSTITester"
        )
        for f in findings:
            f["injection_type"] = "ssti"
        return findings

    async def _test_cmdi(self) -> List[Dict[str, Any]]:
        """Test command injection: Python screen -> commix exploit."""
        findings = []

        # Screen with Python
        screen_findings = await self._run_python_module(
            "phase3_testing.injection.command_injection", "CommandInjectionTester"
        )
        findings.extend(screen_findings)

        # Exploit with commix if screening found something
        if screen_findings and self.exploit and self.router.is_available("commix"):
            commix_findings = await self._run_commix()
            findings.extend(commix_findings)

        for f in findings:
            f["injection_type"] = "cmdi"
        return findings

    async def _test_xxe(self) -> List[Dict[str, Any]]:
        """Test XXE: Python xxe_tester (primary, no Kali equivalent)."""
        findings = await self._run_python_module(
            "phase3_testing.injection.xxe_tester", "XXETester"
        )
        for f in findings:
            f["injection_type"] = "xxe"
        return findings

    async def _run_python_module(
        self, module_path: str, class_name: str
    ) -> List[Dict[str, Any]]:
        """Run a Python testing module and extract findings."""
        findings = []
        try:
            module = __import__(module_path, fromlist=[class_name])
            tester_class = getattr(module, class_name)

            import inspect
            sig = inspect.signature(tester_class.__init__)
            valid_params = set(sig.parameters.keys()) - {"self"}
            kwargs = {}
            if "target" in valid_params:
                kwargs["target"] = self.target
            if "output_dir" in valid_params:
                kwargs["output_dir"] = str(self.output_dir)
            if "proxy" in valid_params and self.proxy:
                kwargs["proxy"] = self.proxy

            tester = tester_class(**kwargs)

            scan_result = None
            for method_name in ["test", "scan", "run"]:
                if hasattr(tester, method_name):
                    scan_result = await getattr(tester, method_name)()
                    break

            if scan_result and hasattr(scan_result, "findings"):
                for finding in scan_result.findings:
                    fd = finding.to_dict() if hasattr(finding, "to_dict") else {}
                    fd["tool"] = f"python_{class_name}"
                    findings.append(fd)

        except Exception as e:
            logger.error(f"Python module {class_name} failed: {e}")

        return findings

    async def _run_sqlmap(self) -> List[Dict[str, Any]]:
        """Run sqlmap for SQLi exploitation."""
        args = [
            "-u", self.target,
            "--batch",
            "--level", "2",
            "--risk", "2",
        ]

        if self.cookie:
            args += ["--cookie", self.cookie]
        if self.data:
            args += ["--data", self.data]
        if self.proxy:
            args += ["--proxy", self.proxy]

        tool_result = await self.router.run_tool(
            "sqlmap", args, target=self.target, timeout=self.timeout
        )

        findings = []
        if tool_result.raw_output and "injectable" in tool_result.raw_output.lower():
            findings.append({
                "title": "SQL Injection Confirmed (sqlmap)",
                "severity": "high",
                "url": self.target,
                "tool": "sqlmap",
                "evidence": tool_result.raw_output[:500],
            })

        return findings

    async def _run_commix(self) -> List[Dict[str, Any]]:
        """Run commix for command injection exploitation."""
        args = [
            "--url", self.target,
            "--batch",
        ]

        if self.cookie:
            args += ["--cookie", self.cookie]
        if self.data:
            args += ["--data", self.data]
        if self.proxy:
            args += ["--proxy", self.proxy]

        tool_result = await self.router.run_tool(
            "commix", args, target=self.target, timeout=self.timeout
        )

        findings = []
        if tool_result.raw_output and "injectable" in tool_result.raw_output.lower():
            findings.append({
                "title": "Command Injection Confirmed (commix)",
                "severity": "critical",
                "url": self.target,
                "tool": "commix",
                "evidence": tool_result.raw_output[:500],
            })

        return findings

    def _severity_breakdown(self, findings: List[Dict]) -> Dict[str, int]:
        """Count findings per severity level."""
        breakdown = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        for f in findings:
            sev = f.get("severity", "info").lower()
            if sev in breakdown:
                breakdown[sev] += 1
        return breakdown


async def main():
    parser = argparse.ArgumentParser(
        description="SHADOW Injection Suite - Coordinated injection testing",
    )
    parser.add_argument("-t", "--target", required=True, help="Target URL with parameters")
    parser.add_argument("-o", "--output", default="results", help="Output directory")
    parser.add_argument("--types", help="Injection types (comma-separated: sqli,xss,ssti,cmdi,xxe)")
    parser.add_argument("--no-exploit", action="store_true", help="Screen only, no exploitation")
    parser.add_argument("--cookie", help="Cookie string")
    parser.add_argument("--data", help="POST data")
    parser.add_argument("--method", default="GET", help="HTTP method")
    parser.add_argument("--timeout", type=int, default=600, help="Timeout in seconds")
    parser.add_argument("--proxy", help="Proxy URL")
    parser.add_argument("--json", action="store_true", help="Output as JSON")

    args = parser.parse_args()
    ensure_dir(args.output)

    types = args.types.split(",") if args.types else None

    suite = InjectionSuite(
        target=args.target,
        output_dir=args.output,
        types=types,
        exploit=not args.no_exploit,
        timeout=args.timeout,
        proxy=args.proxy,
        cookie=args.cookie,
        data=args.data,
        method=args.method,
    )

    result = await suite.run()

    if args.json:
        print(result.to_json())
    else:
        breakdown = result.parsed_data.get("severity_breakdown", {})
        print(f"\nInjection Suite Results: {len(result.findings)} total findings")
        print(f"Types tested: {', '.join(result.parsed_data.get('types_tested', []))}")
        print(f"Severity: C={breakdown.get('critical',0)} H={breakdown.get('high',0)} "
              f"M={breakdown.get('medium',0)} L={breakdown.get('low',0)}\n")

        for finding in result.findings:
            sev = finding.get("severity", "?").upper()
            title = finding.get("title", "Unknown")
            inj_type = finding.get("injection_type", "?")
            tool = finding.get("tool", "?")
            print(f"  [{sev}] [{inj_type}] {title} ({tool})")


if __name__ == "__main__":
    asyncio.run(main())
