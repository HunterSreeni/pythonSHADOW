#!/usr/bin/env python3
"""
SHADOW Access Control Suite - Coordinated access control testing.

Coordinates (all Python-primary, no Kali equivalents):
- idor_tester.py (ID enumeration, horizontal privilege test)
- privilege_escalation.py (vertical privesc, role manipulation)
- access_control.py (method override, path traversal, forced browsing)

Usage (CLI):
    python C_access_suite.py -t https://example.com -o results/
    python C_access_suite.py -t https://example.com --cookie "session=abc" --modules idor,privesc

Usage (importable):
    from C_unified_exploits.C_access_suite import AccessSuite
    suite = AccessSuite(target="https://example.com", cookie="session=abc")
    result = await suite.run()
"""

import argparse
import asyncio
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional

sys.path.insert(0, str(Path(__file__).parent.parent))

from core.utils import setup_logging, normalize_url, timestamp_now, ensure_dir
from C_wrappers.C_tool_router import ToolRouter, UnifiedResult

logger = setup_logging("access_suite")


class AccessSuite:
    """
    Coordinated access control testing suite.

    All Python-primary (no Kali tool equivalents).
    Tests IDOR, privilege escalation, and access control bypass.
    """

    ACCESS_MODULES = ["idor", "privesc", "access_control"]

    def __init__(
        self,
        target: str,
        output_dir: str = "results",
        modules: Optional[List[str]] = None,
        cookie: Optional[str] = None,
        auth_header: Optional[str] = None,
        low_priv_cookie: Optional[str] = None,
        high_priv_cookie: Optional[str] = None,
        timeout: int = 300,
        proxy: Optional[str] = None,
    ):
        self.target = normalize_url(target)
        self.output_dir = Path(output_dir)
        self.modules = [m.lower() for m in (modules or self.ACCESS_MODULES)]
        self.cookie = cookie
        self.auth_header = auth_header
        self.low_priv_cookie = low_priv_cookie
        self.high_priv_cookie = high_priv_cookie
        self.timeout = timeout
        self.proxy = proxy
        self.router = ToolRouter()

    async def run(self) -> UnifiedResult:
        """Run all requested access control tests."""
        logger.info(f"Starting Access Control Suite for: {self.target}")
        result = UnifiedResult(tool_used="access_suite", target=self.target)
        all_findings: List[Dict[str, Any]] = []
        module_results: Dict[str, Any] = {}

        for mod in self.modules:
            logger.info(f"Testing: {mod}")
            try:
                if mod == "idor":
                    findings = await self._test_idor()
                elif mod == "privesc":
                    findings = await self._test_privilege_escalation()
                elif mod == "access_control":
                    findings = await self._test_access_control()
                else:
                    logger.warning(f"  Unknown module: {mod}")
                    continue

                all_findings.extend(findings)
                module_results[mod] = {"findings_count": len(findings)}
                logger.info(f"  {mod}: {len(findings)} findings")

            except Exception as e:
                logger.error(f"  {mod} failed: {e}")
                module_results[mod] = {"error": str(e)}

        result.findings = all_findings
        result.parsed_data = {
            "modules_tested": self.modules,
            "total_findings": len(all_findings),
            "module_results": module_results,
        }

        return result

    async def _test_idor(self) -> List[Dict[str, Any]]:
        """Test IDOR vulnerabilities."""
        return await self._run_python_module(
            "phase3_testing.access.idor_tester", "IDORTester"
        )

    async def _test_privilege_escalation(self) -> List[Dict[str, Any]]:
        """Test privilege escalation vulnerabilities."""
        return await self._run_python_module(
            "phase3_testing.access.privilege_escalation", "PrivilegeEscalationTester"
        )

    async def _test_access_control(self) -> List[Dict[str, Any]]:
        """Test access control bypass (method override, path traversal, forced browsing)."""
        return await self._run_python_module(
            "phase3_testing.access.access_control", "AccessControlTester"
        )

    async def _run_python_module(
        self, module_path: str, class_name: str
    ) -> List[Dict[str, Any]]:
        """Run a Python access control testing module."""
        findings = []
        try:
            module = __import__(module_path, fromlist=[class_name])
            tester_class = getattr(module, class_name)

            import inspect
            sig = inspect.signature(tester_class.__init__)
            valid_params = set(sig.parameters.keys()) - {"self"}
            kwargs: Dict[str, Any] = {}
            if "target" in valid_params:
                kwargs["target"] = self.target
            if "output_dir" in valid_params:
                kwargs["output_dir"] = str(self.output_dir)
            if "proxy" in valid_params and self.proxy:
                kwargs["proxy"] = self.proxy
            if "auth_cookie" in valid_params and self.cookie:
                kwargs["auth_cookie"] = self.cookie
            if "auth_header" in valid_params and self.auth_header:
                kwargs["auth_header"] = self.auth_header

            tester = tester_class(**kwargs)

            scan_result = None
            for method_name in ["test", "scan", "run"]:
                if hasattr(tester, method_name):
                    scan_result = await getattr(tester, method_name)()
                    break

            if scan_result and hasattr(scan_result, "findings"):
                for finding in scan_result.findings:
                    fd = finding.to_dict() if hasattr(finding, "to_dict") else {}
                    fd["tool"] = f"python_{class_name}"
                    fd["category"] = "access_control"
                    findings.append(fd)

        except Exception as e:
            logger.error(f"Python module {class_name} failed: {e}")

        return findings


async def main():
    parser = argparse.ArgumentParser(
        description="SHADOW Access Control Suite - IDOR, privesc, access control bypass",
    )
    parser.add_argument("-t", "--target", required=True, help="Target URL")
    parser.add_argument("-o", "--output", default="results", help="Output directory")
    parser.add_argument("--modules", help="Modules (comma-separated: idor,privesc,access_control)")
    parser.add_argument("--cookie", help="Auth cookie string")
    parser.add_argument("--auth-header", help="Authorization header value")
    parser.add_argument("--timeout", type=int, default=300, help="Timeout in seconds")
    parser.add_argument("--proxy", help="Proxy URL")
    parser.add_argument("--json", action="store_true", help="Output as JSON")

    args = parser.parse_args()
    ensure_dir(args.output)

    modules = args.modules.split(",") if args.modules else None

    suite = AccessSuite(
        target=args.target,
        output_dir=args.output,
        modules=modules,
        cookie=args.cookie,
        auth_header=args.auth_header,
        timeout=args.timeout,
        proxy=args.proxy,
    )

    result = await suite.run()

    if args.json:
        print(result.to_json())
    else:
        print(f"\nAccess Control Suite: {len(result.findings)} findings")
        print(f"Modules tested: {', '.join(result.parsed_data.get('modules_tested', []))}\n")
        for finding in result.findings:
            sev = finding.get("severity", "?").upper()
            title = finding.get("title", "Unknown")
            print(f"  [{sev}] {title}")


if __name__ == "__main__":
    asyncio.run(main())
